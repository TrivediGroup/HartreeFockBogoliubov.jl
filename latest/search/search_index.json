{
    "docs": [
        {
            "location": "/", 
            "text": "HartreeFockBogoliubov.jl Documentation\n\n\n\n\nBasics\n\n\n\n\nHartree-Fock-Bogoliubov Theory\n\n\nHartree-Fock-Bogoliubov Decomposition\n\n\n\n\n\n\nMomentum Space Formulation\n\n\n\n\n\n\nInternals\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex", 
            "title": "Home"
        }, 
        {
            "location": "/#hartreefockbogoliubovjl-documentation", 
            "text": "", 
            "title": "HartreeFockBogoliubov.jl Documentation"
        }, 
        {
            "location": "/#basics", 
            "text": "Hartree-Fock-Bogoliubov Theory  Hartree-Fock-Bogoliubov Decomposition    Momentum Space Formulation", 
            "title": "Basics"
        }, 
        {
            "location": "/#internals", 
            "text": "Internal Documentation  Contents  Index", 
            "title": "Internals"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/", 
            "text": "Hartree-Fock-Bogoliubov Theory\n\n\nThis document contains basics of Hartree-Fock-Bogoliubov Theory. We will follow \nGoodman\n.\n\n\n\n\n\n  H =  \\sum_{ij} T_{ij} c_{i}^{\\dagger} c_{j}\n     + \\frac{1}{4} \\sum_{ijkl} V_{ijkl} c_{i}^{\\dagger} c_{j}^{\\dagger} c_{l} c_{k}\n\n\n\n\n\n\n\n\n\\begin{aligned}\n  \\Gamma_{ij} &= \\sum_{kl} V_{ikjl} \\rho_{lk} \\\\\n  \\Gamma_{ik} &= \\sum_{jl} V_{ijkl} \\rho_{lj} \\\\\n  \\Delta_{ij} &= \\frac{1}{2} \\sum_{kl} V_{ijkl} t_{kl}\n\\end{aligned}\n\n\n\n\n\n\n\n\n\\begin{aligned}\n  \\rho_{ij} &= \\langle c_{j}^{\\dagger} c_{i} \\rangle\n             = \\sum_{n} f(\\epsilon_{n}) u_{in} u_{jn}^{*} \\\\\n  t_{ij}    &= \\langle c_{j} c_{i} \\rangle\n             = \\sum_{n} f(\\epsilon_{n}) u_{in} v_{jn}^{*}\n\\end{aligned}\n\n\n\n\n\n\n\nHartree-Fock-Bogoliubov Decomposition\n\n\n\n\nDiagonal Interaction\n\n\nLet us first consider the \ndiagonal\n interaction of the form\n\n\n\n\n\n  V c_{1}^{\\dagger} c_{2}^{\\dagger} c_{2} c_{1} ,\n\n\n\n\n\nwhich is the Hermitian conjugate of itself. Following \nGoodman\n, this interaction decomposes into the following mean fields in the particle-hole and particle-particle channels:\n\n\n\n\n\n\n\n\nInteraction\n\n\nPH Channel\n\n\nPP Channel\n\n\n\n\n\n\n\n\n\n\nV(1212) =  V\n\n\n\u0393(11) =  V \u03c1(22)\n\n\n\u0394(12) =  \u00bd V t(12)\n\n\n\n\n\n\nV(1221) = -V\n\n\n\u0393(12) = -V \u03c1(12)\n\n\n\u0394(12) = -\u00bd V t(21)\n\n\n\n\n\n\nV(2112) = -V\n\n\n\u0393(21) = -V \u03c1(21)\n\n\n\u0394(21) = -\u00bd V t(12)\n\n\n\n\n\n\nV(2121) =  V\n\n\n\u0393(22) =  V \u03c1(11)\n\n\n\u0394(21) =  \u00bd V t(21)\n\n\n\n\n\n\n\n\nHere, the equal sign '=' does not indicate equality. Rather, it refers to the contribution of the right hand side to the mean field on the left hand side. Some of the mean fields are redundant, as required by the Hermiticity of the Hamiltonian. Overall, we end up with\n\n\n\n\n\n\\begin{aligned}\n\\Gamma_{11} &=  V \\rho_{22} \\\\\n\\Gamma_{12} &= -V \\rho_{12} \\\\\n\\Gamma_{22} &=  V \\rho_{11}\n\\end{aligned}\n\n\n\n\n\nin the particle-hole channel, and \n\n\n\n\n\n\\begin{aligned}\n\\Delta_{12} =  V t_{12}\n\\end{aligned}\n\n\n\n\n\nin the particle-particle channel.\n\n\n\n\nOffdiagonal Interaction\n\n\nNow let us consider the \noffdiagonal\n interaction term of the form\n\n\n\n\n\n  V c_{1}^{\\dagger} c_{2}^{\\dagger} c_{4} c_{3}.\n\n\n\n\n\nGiven this term in the interaction, it is implied that its Hermitian conjugate\n\n\n\n\n\n  V^{*} c_{3}^{\\dagger} c_{4}^{\\dagger} c_{2} c_{1}.\n\n\n\n\n\nis also included in the Hamiltonian. The two terms (the explicit term and its Hermitian conjugate) decomposes into\n\n\n\n\n\n\n\n\nInteraction\n\n\nPH Channel\n\n\nPP-Channel\n\n\n\n\n\n\n\n\n\n\nV(1234) =  V\n\n\n\u0393(13) =  V \u03c1(42)\n\n\n\u0394(12) =  \u00bd V t(34)\n\n\n\n\n\n\nV(1243) = -V\n\n\n\u0393(14) = -V \u03c1(32)\n\n\n\u0394(12) = -\u00bd V t(43)\n\n\n\n\n\n\nV(2134) = -V\n\n\n\u0393(23) = -V \u03c1(41)\n\n\n\u0394(21) = -\u00bd V t(34)\n\n\n\n\n\n\nV(2143) =  V\n\n\n\u0393(24) =  V \u03c1(31)\n\n\n\u0394(21) =  \u00bd V t(43)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nV(3412) =  V*\n\n\n\u0393(31) =  V \u03c1(24)\n\n\n\u0394(34) =  \u00bd V t(12)\n\n\n\n\n\n\nV(3421) = -V*\n\n\n\u0393(32) = -V \u03c1(14)\n\n\n\u0394(34) = -\u00bd V t(21)\n\n\n\n\n\n\nV(4312) = -V*\n\n\n\u0393(41) = -V \u03c1(23)\n\n\n\u0394(43) = -\u00bd V t(12)\n\n\n\n\n\n\nV(4321) =  V*\n\n\n\u0393(42) =  V \u03c1(13)\n\n\n\u0394(43) =  \u00bd V t(21)\n\n\n\n\n\n\n\n\nAs we have mentioned above for the diagonal interaction terms, this table contains redundant mean fields. Overwall. we have\n\n\n\n\n\n\\begin{aligned}\n\\Gamma_{13} &=  V  \\rho_{24}^* \\\\\n\\Gamma_{14} &= -V  \\rho_{23}^* \\\\\n\\Gamma_{23} &= -V  \\rho_{14}^* \\\\\n\\Gamma_{24} &=  V  \\rho_{13}^*\n\\end{aligned}\n\n\n\n\n\nin the particle-hole channel and\n\n\n\n\n\n\\begin{aligned}\n\\Delta_{12} &=  V   t_{34} \\\\\n\\Delta_{34} &=  V^* t_{12}\n\\end{aligned}\n\n\n\n\n\nin the particle-particle channel.", 
            "title": "Hartree-Fock-Bogoliubov Theory"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/#hartree-fock-bogoliubov-theory", 
            "text": "This document contains basics of Hartree-Fock-Bogoliubov Theory. We will follow  Goodman .   \n  H =  \\sum_{ij} T_{ij} c_{i}^{\\dagger} c_{j}\n     + \\frac{1}{4} \\sum_{ijkl} V_{ijkl} c_{i}^{\\dagger} c_{j}^{\\dagger} c_{l} c_{k}    \n\\begin{aligned}\n  \\Gamma_{ij} &= \\sum_{kl} V_{ikjl} \\rho_{lk} \\\\\n  \\Gamma_{ik} &= \\sum_{jl} V_{ijkl} \\rho_{lj} \\\\\n  \\Delta_{ij} &= \\frac{1}{2} \\sum_{kl} V_{ijkl} t_{kl}\n\\end{aligned}    \n\\begin{aligned}\n  \\rho_{ij} &= \\langle c_{j}^{\\dagger} c_{i} \\rangle\n             = \\sum_{n} f(\\epsilon_{n}) u_{in} u_{jn}^{*} \\\\\n  t_{ij}    &= \\langle c_{j} c_{i} \\rangle\n             = \\sum_{n} f(\\epsilon_{n}) u_{in} v_{jn}^{*}\n\\end{aligned}", 
            "title": "Hartree-Fock-Bogoliubov Theory"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/#hartree-fock-bogoliubov-decomposition", 
            "text": "", 
            "title": "Hartree-Fock-Bogoliubov Decomposition"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/#diagonal-interaction", 
            "text": "Let us first consider the  diagonal  interaction of the form   \n  V c_{1}^{\\dagger} c_{2}^{\\dagger} c_{2} c_{1} ,   which is the Hermitian conjugate of itself. Following  Goodman , this interaction decomposes into the following mean fields in the particle-hole and particle-particle channels:     Interaction  PH Channel  PP Channel      V(1212) =  V  \u0393(11) =  V \u03c1(22)  \u0394(12) =  \u00bd V t(12)    V(1221) = -V  \u0393(12) = -V \u03c1(12)  \u0394(12) = -\u00bd V t(21)    V(2112) = -V  \u0393(21) = -V \u03c1(21)  \u0394(21) = -\u00bd V t(12)    V(2121) =  V  \u0393(22) =  V \u03c1(11)  \u0394(21) =  \u00bd V t(21)     Here, the equal sign '=' does not indicate equality. Rather, it refers to the contribution of the right hand side to the mean field on the left hand side. Some of the mean fields are redundant, as required by the Hermiticity of the Hamiltonian. Overall, we end up with   \n\\begin{aligned}\n\\Gamma_{11} &=  V \\rho_{22} \\\\\n\\Gamma_{12} &= -V \\rho_{12} \\\\\n\\Gamma_{22} &=  V \\rho_{11}\n\\end{aligned}   in the particle-hole channel, and    \n\\begin{aligned}\n\\Delta_{12} =  V t_{12}\n\\end{aligned}   in the particle-particle channel.", 
            "title": "Diagonal Interaction"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/#offdiagonal-interaction", 
            "text": "Now let us consider the  offdiagonal  interaction term of the form   \n  V c_{1}^{\\dagger} c_{2}^{\\dagger} c_{4} c_{3}.   Given this term in the interaction, it is implied that its Hermitian conjugate   \n  V^{*} c_{3}^{\\dagger} c_{4}^{\\dagger} c_{2} c_{1}.   is also included in the Hamiltonian. The two terms (the explicit term and its Hermitian conjugate) decomposes into     Interaction  PH Channel  PP-Channel      V(1234) =  V  \u0393(13) =  V \u03c1(42)  \u0394(12) =  \u00bd V t(34)    V(1243) = -V  \u0393(14) = -V \u03c1(32)  \u0394(12) = -\u00bd V t(43)    V(2134) = -V  \u0393(23) = -V \u03c1(41)  \u0394(21) = -\u00bd V t(34)    V(2143) =  V  \u0393(24) =  V \u03c1(31)  \u0394(21) =  \u00bd V t(43)         V(3412) =  V*  \u0393(31) =  V \u03c1(24)  \u0394(34) =  \u00bd V t(12)    V(3421) = -V*  \u0393(32) = -V \u03c1(14)  \u0394(34) = -\u00bd V t(21)    V(4312) = -V*  \u0393(41) = -V \u03c1(23)  \u0394(43) = -\u00bd V t(12)    V(4321) =  V*  \u0393(42) =  V \u03c1(13)  \u0394(43) =  \u00bd V t(21)     As we have mentioned above for the diagonal interaction terms, this table contains redundant mean fields. Overwall. we have   \n\\begin{aligned}\n\\Gamma_{13} &=  V  \\rho_{24}^* \\\\\n\\Gamma_{14} &= -V  \\rho_{23}^* \\\\\n\\Gamma_{23} &= -V  \\rho_{14}^* \\\\\n\\Gamma_{24} &=  V  \\rho_{13}^*\n\\end{aligned}   in the particle-hole channel and   \n\\begin{aligned}\n\\Delta_{12} &=  V   t_{34} \\\\\n\\Delta_{34} &=  V^* t_{12}\n\\end{aligned}   in the particle-particle channel.", 
            "title": "Offdiagonal Interaction"
        }, 
        {
            "location": "/basics/momentumspace/", 
            "text": "Momentum Space Formulation\n\n\nHopping Elements\n\n\n\n\n\n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})\n\n\n\n\n\nPairing Elements\n\n\n\n\n\n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}^{*}(-\\mathbf{k})\n\n\n\n\n\n\n\n\n\\sum_{\\mathbf{R}}\n    c_{\\alpha}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta) \n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}(-\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})\n\n\n\n\n\nExpectation Values\n\n\n\n\n\n\\rho_{\\alpha \\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta} - \\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n       f(\\epsilon_n) U_{\\alpha n} U_{\\beta n}^{*}\n\n\n\n\n\n\n\n\nt_{\\alpha\\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}_\\alpha, \\mathbf{k}_\\beta}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta}\n                        -\\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n        f(\\epsilon_n )\n        U_{\\alpha n}\n        V_{\\beta n}^{*}", 
            "title": "Momentum Space Formulation"
        }, 
        {
            "location": "/basics/momentumspace/#momentum-space-formulation", 
            "text": "Hopping Elements   \n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})   Pairing Elements   \n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}^{*}(-\\mathbf{k})    \n\\sum_{\\mathbf{R}}\n    c_{\\alpha}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta) \n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}(-\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})   Expectation Values   \n\\rho_{\\alpha \\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta} - \\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n       f(\\epsilon_n) U_{\\alpha n} U_{\\beta n}^{*}    \nt_{\\alpha\\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}_\\alpha, \\mathbf{k}_\\beta}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta}\n                        -\\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n        f(\\epsilon_n )\n        U_{\\alpha n}\n        V_{\\beta n}^{*}", 
            "title": "Momentum Space Formulation"
        }, 
        {
            "location": "/about/", 
            "text": "About", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "", 
            "title": "About"
        }, 
        {
            "location": "/internals/", 
            "text": "Internal Documentation\n\n\nThis page lists all the documented internals of the \nHartreeFockBogoliubov\n module and submodules.\n\n\n\n\nContents\n\n\n\n\nLattice\n\n\nSpec\n\n\nGenerator\n\n\nTopology\n\n\nHFB\n\n\nLinearizedGap\n\n\n\n\n\n\nIndex\n\n\nA list of all internal documentation sorted by module.\n\n\n\n\nHartreeFockBogoliubov.Spec\n\n\nHartreeFockBogoliubov.Spec.Hopping\n\n\nHartreeFockBogoliubov.Spec.Interaction\n\n\nHartreeFockBogoliubov.HFB.CollectRow\n\n\nHartreeFockBogoliubov.HFB.DeployRow\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n\n\nHartreeFockBogoliubov.HFB.HoppingMeanField\n\n\nHartreeFockBogoliubov.HFB.PairingMeanField\n\n\nHartreeFockBogoliubov.Lattice.CarteCoord\n\n\nHartreeFockBogoliubov.Lattice.FractCoord\n\n\nHartreeFockBogoliubov.Lattice.UnitCell\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n\n\nHartreeFockBogoliubov.Spec.HoppingOffdiagonal\n\n\nHartreeFockBogoliubov.Spec.InteractionDiagonal\n\n\nHartreeFockBogoliubov.Spec.InteractionOffdiagonal\n\n\nHartreeFockBogoliubov.Generator.generatefast\n\n\nHartreeFockBogoliubov.Generator.generatefast\n\n\nHartreeFockBogoliubov.Generator.generatefast\n\n\nHartreeFockBogoliubov.Generator.generatehoppingfast\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n\n\nHartreeFockBogoliubov.HFB.computetargetfields\n\n\nHartreeFockBogoliubov.HFB.fixhfbsolution\n\n\nHartreeFockBogoliubov.HFB.freeze\n\n\nHartreeFockBogoliubov.HFB.getnextsolution\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionpython\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionthreaded\n\n\nHartreeFockBogoliubov.HFB.makeDeltamatrix\n\n\nHartreeFockBogoliubov.HFB.makeGammamatrix\n\n\nHartreeFockBogoliubov.HFB.makegreencollectors\n\n\nHartreeFockBogoliubov.HFB.makehamiltonian\n\n\nHartreeFockBogoliubov.HFB.makehoppingmatrix\n\n\nHartreeFockBogoliubov.HFB.makeparticleholeregistry\n\n\nHartreeFockBogoliubov.HFB.makeparticleparticleregistry\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.newhfbhint\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n\n\nHartreeFockBogoliubov.HFB.randomize!\n\n\nHartreeFockBogoliubov.Lattice.addorbital!\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n\n\nHartreeFockBogoliubov.Lattice.dimension\n\n\nHartreeFockBogoliubov.Lattice.dimension\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindex\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindexcoord\n\n\nHartreeFockBogoliubov.Lattice.getorbitalname\n\n\nHartreeFockBogoliubov.Lattice.hasorbital\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n\n\nHartreeFockBogoliubov.Lattice.numorbital\n\n\nHartreeFockBogoliubov.Lattice.whichunitcell\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n\n\nHartreeFockBogoliubov.Topology.squarify\n\n\nHartreeFockBogoliubov.Topology.squarify\n\n\nHartreeFockBogoliubov.Topology.squarify\n\n\nHartreeFockBogoliubov.Topology.timereversalindexgrid\n\n\nHartreeFockBogoliubov.Topology.z2index", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#internal-documentation", 
            "text": "This page lists all the documented internals of the  HartreeFockBogoliubov  module and submodules.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/internals/#contents", 
            "text": "Lattice  Spec  Generator  Topology  HFB  LinearizedGap", 
            "title": "Contents"
        }, 
        {
            "location": "/internals/#index", 
            "text": "A list of all internal documentation sorted by module.   HartreeFockBogoliubov.Spec  HartreeFockBogoliubov.Spec.Hopping  HartreeFockBogoliubov.Spec.Interaction  HartreeFockBogoliubov.HFB.CollectRow  HartreeFockBogoliubov.HFB.DeployRow  HartreeFockBogoliubov.HFB.HFBComputer  HartreeFockBogoliubov.HFB.HFBComputer  HartreeFockBogoliubov.HFB.HFBHamiltonian  HartreeFockBogoliubov.HFB.HFBHamiltonian  HartreeFockBogoliubov.HFB.HFBHamiltonian  HartreeFockBogoliubov.HFB.HFBSolver  HartreeFockBogoliubov.HFB.HFBSolver  HartreeFockBogoliubov.HFB.HoppingMeanField  HartreeFockBogoliubov.HFB.PairingMeanField  HartreeFockBogoliubov.Lattice.CarteCoord  HartreeFockBogoliubov.Lattice.FractCoord  HartreeFockBogoliubov.Lattice.UnitCell  HartreeFockBogoliubov.Spec.FullHamiltonian  HartreeFockBogoliubov.Spec.FullHamiltonian  HartreeFockBogoliubov.Spec.HoppingDiagonal  HartreeFockBogoliubov.Spec.HoppingDiagonal  HartreeFockBogoliubov.Spec.HoppingOffdiagonal  HartreeFockBogoliubov.Spec.InteractionDiagonal  HartreeFockBogoliubov.Spec.InteractionOffdiagonal  HartreeFockBogoliubov.Generator.generatefast  HartreeFockBogoliubov.Generator.generatefast  HartreeFockBogoliubov.Generator.generatefast  HartreeFockBogoliubov.Generator.generatehoppingfast  HartreeFockBogoliubov.HFB.addinteraction!  HartreeFockBogoliubov.HFB.addinteraction!  HartreeFockBogoliubov.HFB.computetargetfields  HartreeFockBogoliubov.HFB.fixhfbsolution  HartreeFockBogoliubov.HFB.freeze  HartreeFockBogoliubov.HFB.getnextsolution  HartreeFockBogoliubov.HFB.getnextsolutionpython  HartreeFockBogoliubov.HFB.getnextsolutionthreaded  HartreeFockBogoliubov.HFB.makeDeltamatrix  HartreeFockBogoliubov.HFB.makeGammamatrix  HartreeFockBogoliubov.HFB.makegreencollectors  HartreeFockBogoliubov.HFB.makehamiltonian  HartreeFockBogoliubov.HFB.makehoppingmatrix  HartreeFockBogoliubov.HFB.makeparticleholeregistry  HartreeFockBogoliubov.HFB.makeparticleparticleregistry  HartreeFockBogoliubov.HFB.makesourcefields  HartreeFockBogoliubov.HFB.makesourcefields  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.newhfbhint  HartreeFockBogoliubov.HFB.newhfbsolution  HartreeFockBogoliubov.HFB.newhfbsolution  HartreeFockBogoliubov.HFB.randomize!  HartreeFockBogoliubov.Lattice.addorbital!  HartreeFockBogoliubov.Lattice.carte2fract  HartreeFockBogoliubov.Lattice.carte2fract  HartreeFockBogoliubov.Lattice.dimension  HartreeFockBogoliubov.Lattice.dimension  HartreeFockBogoliubov.Lattice.fract2carte  HartreeFockBogoliubov.Lattice.fract2carte  HartreeFockBogoliubov.Lattice.getorbital  HartreeFockBogoliubov.Lattice.getorbital  HartreeFockBogoliubov.Lattice.getorbitalcoord  HartreeFockBogoliubov.Lattice.getorbitalcoord  HartreeFockBogoliubov.Lattice.getorbitalindex  HartreeFockBogoliubov.Lattice.getorbitalindexcoord  HartreeFockBogoliubov.Lattice.getorbitalname  HartreeFockBogoliubov.Lattice.hasorbital  HartreeFockBogoliubov.Lattice.newunitcell  HartreeFockBogoliubov.Lattice.newunitcell  HartreeFockBogoliubov.Lattice.numorbital  HartreeFockBogoliubov.Lattice.whichunitcell  HartreeFockBogoliubov.Spec.addhopping!  HartreeFockBogoliubov.Spec.addhopping!  HartreeFockBogoliubov.Spec.addinteraction!  HartreeFockBogoliubov.Spec.addinteraction!  HartreeFockBogoliubov.Spec.hoppingbycarte  HartreeFockBogoliubov.Spec.hoppingbycarte  HartreeFockBogoliubov.Spec.interactionbycarte  HartreeFockBogoliubov.Spec.interactionbycarte  HartreeFockBogoliubov.Topology.squarify  HartreeFockBogoliubov.Topology.squarify  HartreeFockBogoliubov.Topology.squarify  HartreeFockBogoliubov.Topology.timereversalindexgrid  HartreeFockBogoliubov.Topology.z2index", 
            "title": "Index"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/", 
            "text": "Lattice\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.CarteCoord\n \n \nType\n.\n\n\nCarteCoord\n\n\nCartesian coordinates. \nVector{Float64}\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.FractCoord\n \n \nType\n.\n\n\nFractCoord\n\n\nFractional coordinates.\n\n\nMembers\n\n\n\n\nwhole ::Vector{Int64}\n: Integer part of fractional coordinates\n\n\nfraction ::Vector{Float64}\n: [0,1) part of fractional coordinates\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.UnitCell\n \n \nType\n.\n\n\nUnitCell{T}\n\n\n\n\nMembers\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n: Lattice vectors\n\n\nreducedreciprocallatticevectors ::Array{Float64, 2}\n: Reduced reciprocal lattice vectors (transpose of inverse of \nlatticevectors\n)\n\n\nreciprocallatticevectors ::Array{Float64, 2}\n: Reciprocal lattice vectors\n\n\norbitals ::Vector{Tuple{T, FractCoord}}\n: List of orbitals within unit cell\n\n\norbitalindices ::Dict{T, Int64}\n: Indices of orbitals\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.addorbital!\n \n \nMethod\n.\n\n\naddorbital!\n\n\n\n\nAdd an orbital to the unit cell.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\norbitalname ::{T}\n\n\norbitalcoord ::FractCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n \n \nMethod\n.\n\n\ncarte2fract\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\ncc ::CarteCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n \n \nMethod\n.\n\n\ncarte2fract\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\ncc ::CarteCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.dimension\n \n \nMethod\n.\n\n\ndimension\n\n\nDimension of the fractional coordinates\n\n\nArguments\n\n\n\n\nfc ::FractCoord\n: Fractional coordinates.\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.dimension\n \n \nMethod\n.\n\n\ndimension\n\n\n\n\nSpatial dimension of the unit cell.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n \n \nMethod\n.\n\n\nfract2carte\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\nfc ::FractCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n \n \nMethod\n.\n\n\nfract2carte\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\nfc ::FractCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n \n \nMethod\n.\n\n\ngetorbital\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\nidx ::Integer\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n \n \nMethod\n.\n\n\ngetorbital\n\n\nGet the orbital with the given name.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n \n \nMethod\n.\n\n\ngetorbitalcoord\n\n\nArguments\n\n\n\n\nuc ::UnitCell\n\n\nidx ::Integer\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n \n \nMethod\n.\n\n\ngetorbitalcoord\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindex\n \n \nMethod\n.\n\n\ngetorbitalindex\n\n\n\n\nGet index of the given orbital.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindexcoord\n \n \nMethod\n.\n\n\ngetorbitalindexcoord\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\nname ::T\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalname\n \n \nMethod\n.\n\n\ngetorbitalname\n\n\nArguments\n\n\n\n\nuc ::UnitCell\n\n\nidx ::Integer\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.hasorbital\n \n \nMethod\n.\n\n\nhasorbital{T}\n\n\n\n\nTest whether the unit cell contains the orbital of given name.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n \n \nMethod\n.\n\n\nUnitCell\n\n\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n: Lattice vectors\n\n\nOrbitalType::DataType\n\n\n\n\nOptional Arguments\n\n\n\n\ntol=sqrt(eps(Float64))\n: Epsilon\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n \n \nMethod\n.\n\n\nUnitCell\n\n\n\n\nConstruct a one-dimensional lattice.\n\n\nArguments\n\n\n\n\nlatticeconstant ::Float64\n: Lattice constant\n\n\nOrbitalType\n: List of orbitals\n\n\n\n\nOptional Arguments\n\n\n\n\ntol=sqrt(eps(Float64))\n: Tolerance\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.numorbital\n \n \nMethod\n.\n\n\nnumorbital\n\n\n\n\nNumber of orbitals of the unit cell.\n\n\nArguments\n\n\n\n\nuc ::UnitCell\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.whichunitcell\n \n \nMethod\n.\n\n\nwhichunitcell\n\n\nReturn which unit cell the specificied orbital/cartesian coordinates belongs to.\n\n\nsource\n\n\n\n\nSpec\n\n\n#\n\n\nHartreeFockBogoliubov.Spec\n \n \nModule\n.\n\n\nSubmodule `Spec`\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.Hopping\n \n \nConstant\n.\n\n\nHopping\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.Interaction\n \n \nConstant\n.\n\n\nInteraction\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n \n \nType\n.\n\n\nFullHamiltonian\n\n\n\n\nMembers\n\n\n\n\nunitcell ::UnitCell\n\n\nhoppings ::Vector{Hopping}\n\n\ninteractions ::Vector{Interaction}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n \n \nMethod\n.\n\n\nHamiltonian\n\n\n\n\nCreate an empty Hamiltonian\n\n\nArguments\n\n\n\n\nunitcell ::UnitCell\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n \n \nType\n.\n\n\nHoppingDiagonal{R\n:Real}\n\n\n\n\nRepresents\n\n\n\n\n\n  t c_{i}^{*} c_{i}\n\n\n\n\n\nMembers\n\n\n\n\namplitude ::R\n\n\ni ::Int64\n: name of orbital\n\n\nRi ::Vector{Int64}\n: which unit cell? (indexed by a1, and a2)\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.HoppingOffdiagonal\n \n \nType\n.\n\n\nHoppingOffdiagonal{C\n:Number}\n\n\n\n\nRepresents\n\n\n\n\n\n  t c_{i}^{*} c_{j} + t^* c_{j}^{*} c_{i}\n\n\n\n\n\nMembers\n\n\n\n\namplitude :: C\n\n\ni ::T\n\n\nj ::T\n\n\nRi ::Vector{Int64}\n\n\nRj ::Vector{Int64}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.InteractionDiagonal\n \n \nType\n.\n\n\nInteractionDiagonal{R\n:Real}\n\n\n\n\nRepresents\n\n\n\n\n\n    U c_{i}^{*} c_{j}^{*} c_{j} c_{i}\n\n\n\n\n\nMembers\n\n\n\n\namplitude ::R\n\n\ni ::T\n\n\nj ::T\n\n\nRi ::Vector{Int64}\n\n\nRj ::Vector{Int64}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.InteractionOffdiagonal\n \n \nType\n.\n\n\nInteractionOffdiagonal{C\n:Number}\n\ni \n j, k \n l, i \n k or (i == k and j \n l)\n\n\n\n\nRepresents\n\n\n\n\n\n   U     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n + U^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}\n\n\n\n\n\nOnly keep the first term (and require i \n j, k \n l, i \n= k)\n\n\nMembers\n\n\n\n\namplitude ::C\n\n\ni ::T\n\n\nj ::T\n\n\nk ::T\n\n\nl ::T\n\n\nRi ::Vector{Int64}\n\n\nRj ::Vector{Int64}\n\n\nRk ::Vector{Int64}\n\n\nRl ::Vector{Int64}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n \n \nMethod\n.\n\n\naddhopping!\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\nhopping ::HoppingOffdiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n \n \nMethod\n.\n\n\naddhopping!\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\nhopping ::HoppingDiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n \n \nMethod\n.\n\n\naddinteraction!\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\ninteraction ::InteractionOffdiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n \n \nMethod\n.\n\n\naddinteraction!\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\ninteraction ::InteractionDiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n \n \nMethod\n.\n\n\nhoppingbycarte{T}\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\namplitude ::Number\n\n\ni ::T\n\n\nj ::T\n\n\nri ::CarteCoord\n\n\nrj ::CarteCoord\n\n\ntol ::Real\n : Optional. Defaults to \nsqrt(eps(Float64))\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n \n \nMethod\n.\n\n\nhoppingbycarte{T}\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\namplitude ::Real\n\n\ni ::T\n\n\nri ::CarteCoord\n\n\ntol ::Real\n : Optional. Defaults to \nsqrt(eps(Float64))\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n \n \nMethod\n.\n\n\ninteractionbycarte{T}\n\n\n\n\nArguments\n\n\n* `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `k ::T`\n* `l ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `rk ::CarteCoord`\n* `rl ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n \n \nMethod\n.\n\n\ninteractionbycarte{T}\n\n\n\n\nArguments\n\n\n* `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`\n\n\n\n\nsource\n\n\n\n\nGenerator\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatefast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatefast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatefast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatehoppingfast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\nsource\n\n\n\n\nTopology\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.squarify\n \n \nMethod\n.\n\n\nsquarify\n\n\n\n\nArguments\n\n\n\n\nuc::HFB.HFBHamiltonian{O}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.squarify\n \n \nMethod\n.\n\n\nsquarify\n\n\n\n\nIn order to make the Hamiltoinian a periodic function of momentum, bring all the sites to the origin. In addition, make the unitcell into a square.\n\n\nArguments\n\n\n\n\nuc::Lattice.UnitCell{O}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.squarify\n \n \nMethod\n.\n\n\nsquarify\n\n\n\n\nArguments\n\n\n\n\nuc::Spec.FullHamiltonian{O}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.timereversalindexgrid\n \n \nMethod\n.\n\n\ngenerate k-space grid (which has (2 n1, 2 n2) points TOTAL in the Brillouin zone)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.z2index\n \n \nMethod\n.\n\n\nz2index\n\n\nCompute Z2 index of time-reversal-invariant Hamiltonian.\n\n\nArguments\n\n\n\n\nuc::UnitCell{O}\n\n\nhops::AbstractVector{Hopping}\n\n\ntimereversal::AbstractMatrix\n\n\nn1 ::Integer\n\n\nn2 ::Integer\n\n\nselectpairs::AbstractVector{\n:Integer}\n\n\n\n\nOptional Arguments\n\n\n\n\ntol ::Real = sqrt(eps(Float64))\n\n\n\n\nReturn\n\n\nsource\n\n\n\n\nHFB\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n \n \nType\n.\n\n\nHFBConmputer\n is a type holding the \u03c1, t and \u0393, \u0394 of a Hartree-Fock-Bogoliubov Hamiltonian.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n \n \nMethod\n.\n\n\nAdd offdiagonal interaction\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n \n \nMethod\n.\n\n\nAdd diagonal interaction\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.computetargetfields\n \n \nMethod\n.\n\n\nCompute \u0393 and \u0394 from \u03c1 and t.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.fixhfbsolution\n \n \nMethod\n.\n\n\nRecompute \u0393 and \u0394 from \u03c1 and t in a \nHFBSolution\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.freeze\n \n \nMethod\n.\n\n\nfreeze\n\nCreate a hopping hamiltonian out of HFB Hamiltonian and Solution\n\nOrder:\nelectrons......, HOLE......\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.getnextsolution\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionpython\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeDeltamatrix\n \n \nMethod\n.\n\n\nReturn a generator of \u0394 matrix (which is a function of momentum)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeGammamatrix\n \n \nMethod\n.\n\n\nReturn a generator of \u0393 matrix (which is a function of momentum)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makegreencollectors\n \n \nMethod\n.\n\n\nmakegreencollectors\n\n\n\n\nReturns a function which has the following signature\n\n\ncollector(k, eigenvalues, eigenvectors, \u03c1out, tout)\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makehamiltonian\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makehoppingmatrix\n \n \nMethod\n.\n\n\nReturn a generator of hopping matrix (which is a function of momentum)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n \n \nMethod\n.\n\n\nfunc : (idx, i, j, r) -\n val\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n \n \nMethod\n.\n\n\nfunc : (idx, i, j, r) -\n 0\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.newhfbhint\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n \n \nMethod\n.\n\n\nCheck if hint contains \u03c1\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n \n \nMethod\n.\n\n\nReturn a zero solution\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.randomize!\n \n \nMethod\n.\n\n\nRandomize a solution\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.CollectRow\n \n \nType\n.\n\n\nCollectRow\n is holds info on how to compute \u03c1 or t. Its elements are:\n\n\n\n\nIs diagonal? (only for rho)\n\n\nrow orbital\n\n\ncol orbital\n\n\ndisplacement r(col) - r(row)\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.DeployRow\n \n \nType\n.\n\n\nDeployRow\n is holds info on how to compute \u0393 or \u0394. Its elements are:\n\n\n\n\nIs diagonal\n\n\nrow orbital\n\n\ncol orbital\n\n\ndisplacement r(col) - r(row)\n\n\nlist of sources, each of which is a tuple of\n\n\nindex of \u03c1 or t from which to compute this \u0393 or \u0394.\n\n\namplitude (coefficient to multiply to \u03c1 or t)\n\n\nboolean indicating whether   (1) conjugation is needed (for \u03c1/\u0393) or   (2) minus sign is needed (for t/\u0394).\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HoppingMeanField\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.PairingMeanField\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionthreaded\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeparticleholeregistry\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeparticleparticleregistry\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n\n\nLinearizedGap", 
            "title": "More"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#lattice", 
            "text": "#  HartreeFockBogoliubov.Lattice.CarteCoord     Type .  CarteCoord  Cartesian coordinates.  Vector{Float64} .  source  #  HartreeFockBogoliubov.Lattice.FractCoord     Type .  FractCoord  Fractional coordinates.  Members   whole ::Vector{Int64} : Integer part of fractional coordinates  fraction ::Vector{Float64} : [0,1) part of fractional coordinates   source  #  HartreeFockBogoliubov.Lattice.UnitCell     Type .  UnitCell{T}  Members   latticevectors ::Array{Float64, 2} : Lattice vectors  reducedreciprocallatticevectors ::Array{Float64, 2} : Reduced reciprocal lattice vectors (transpose of inverse of  latticevectors )  reciprocallatticevectors ::Array{Float64, 2} : Reciprocal lattice vectors  orbitals ::Vector{Tuple{T, FractCoord}} : List of orbitals within unit cell  orbitalindices ::Dict{T, Int64} : Indices of orbitals   source  #  HartreeFockBogoliubov.Lattice.addorbital!     Method .  addorbital!  Add an orbital to the unit cell.  Arguments   uc ::UnitCell{T}  orbitalname ::{T}  orbitalcoord ::FractCoord   source  #  HartreeFockBogoliubov.Lattice.carte2fract     Method .  carte2fract  Arguments   latticevectors ::Array{Float64, 2}  cc ::CarteCoord   source  #  HartreeFockBogoliubov.Lattice.carte2fract     Method .  carte2fract  Arguments   latticevectors ::Array{Float64, 2}  cc ::CarteCoord   source  #  HartreeFockBogoliubov.Lattice.dimension     Method .  dimension  Dimension of the fractional coordinates  Arguments   fc ::FractCoord : Fractional coordinates.   source  #  HartreeFockBogoliubov.Lattice.dimension     Method .  dimension  Spatial dimension of the unit cell.  source  #  HartreeFockBogoliubov.Lattice.fract2carte     Method .  fract2carte  Arguments   latticevectors ::Array{Float64, 2}  fc ::FractCoord   source  #  HartreeFockBogoliubov.Lattice.fract2carte     Method .  fract2carte  Arguments   latticevectors ::Array{Float64, 2}  fc ::FractCoord   source  #  HartreeFockBogoliubov.Lattice.getorbital     Method .  getorbital  Arguments   uc ::UnitCell{T}  idx ::Integer   source  #  HartreeFockBogoliubov.Lattice.getorbital     Method .  getorbital  Get the orbital with the given name.  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.getorbitalcoord     Method .  getorbitalcoord  Arguments   uc ::UnitCell  idx ::Integer   source  #  HartreeFockBogoliubov.Lattice.getorbitalcoord     Method .  getorbitalcoord  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.getorbitalindex     Method .  getorbitalindex  Get index of the given orbital.  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.getorbitalindexcoord     Method .  getorbitalindexcoord  Arguments   uc ::UnitCell{T}  name ::T   source  #  HartreeFockBogoliubov.Lattice.getorbitalname     Method .  getorbitalname  Arguments   uc ::UnitCell  idx ::Integer   source  #  HartreeFockBogoliubov.Lattice.hasorbital     Method .  hasorbital{T}  Test whether the unit cell contains the orbital of given name.  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.newunitcell     Method .  UnitCell  Arguments   latticevectors ::Array{Float64, 2} : Lattice vectors  OrbitalType::DataType   Optional Arguments   tol=sqrt(eps(Float64)) : Epsilon   source  #  HartreeFockBogoliubov.Lattice.newunitcell     Method .  UnitCell  Construct a one-dimensional lattice.  Arguments   latticeconstant ::Float64 : Lattice constant  OrbitalType : List of orbitals   Optional Arguments   tol=sqrt(eps(Float64)) : Tolerance   source  #  HartreeFockBogoliubov.Lattice.numorbital     Method .  numorbital  Number of orbitals of the unit cell.  Arguments   uc ::UnitCell   source  #  HartreeFockBogoliubov.Lattice.whichunitcell     Method .  whichunitcell  Return which unit cell the specificied orbital/cartesian coordinates belongs to.  source", 
            "title": "Lattice"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#spec", 
            "text": "#  HartreeFockBogoliubov.Spec     Module .  Submodule `Spec`  source  #  HartreeFockBogoliubov.Spec.Hopping     Constant .  Hopping  source  #  HartreeFockBogoliubov.Spec.Interaction     Constant .  Interaction  source  #  HartreeFockBogoliubov.Spec.FullHamiltonian     Type .  FullHamiltonian  Members   unitcell ::UnitCell  hoppings ::Vector{Hopping}  interactions ::Vector{Interaction}   source  #  HartreeFockBogoliubov.Spec.FullHamiltonian     Method .  Hamiltonian  Create an empty Hamiltonian  Arguments   unitcell ::UnitCell   source  #  HartreeFockBogoliubov.Spec.HoppingDiagonal     Type .  HoppingDiagonal{R :Real}  Represents   \n  t c_{i}^{*} c_{i}   Members   amplitude ::R  i ::Int64 : name of orbital  Ri ::Vector{Int64} : which unit cell? (indexed by a1, and a2)   source  #  HartreeFockBogoliubov.Spec.HoppingDiagonal     Method .  source  #  HartreeFockBogoliubov.Spec.HoppingOffdiagonal     Type .  HoppingOffdiagonal{C :Number}  Represents   \n  t c_{i}^{*} c_{j} + t^* c_{j}^{*} c_{i}   Members   amplitude :: C  i ::T  j ::T  Ri ::Vector{Int64}  Rj ::Vector{Int64}   source  #  HartreeFockBogoliubov.Spec.InteractionDiagonal     Type .  InteractionDiagonal{R :Real}  Represents   \n    U c_{i}^{*} c_{j}^{*} c_{j} c_{i}   Members   amplitude ::R  i ::T  j ::T  Ri ::Vector{Int64}  Rj ::Vector{Int64}   source  #  HartreeFockBogoliubov.Spec.InteractionOffdiagonal     Type .  InteractionOffdiagonal{C :Number}\n\ni   j, k   l, i   k or (i == k and j   l)  Represents   \n   U     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n + U^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}   Only keep the first term (and require i   j, k   l, i  = k)  Members   amplitude ::C  i ::T  j ::T  k ::T  l ::T  Ri ::Vector{Int64}  Rj ::Vector{Int64}  Rk ::Vector{Int64}  Rl ::Vector{Int64}   source  #  HartreeFockBogoliubov.Spec.addhopping!     Method .  addhopping!  Arguments   hamiltonian ::Hamiltonian  hopping ::HoppingOffdiagonal   source  #  HartreeFockBogoliubov.Spec.addhopping!     Method .  addhopping!  Arguments   hamiltonian ::Hamiltonian  hopping ::HoppingDiagonal   source  #  HartreeFockBogoliubov.Spec.addinteraction!     Method .  addinteraction!  Arguments   hamiltonian ::Hamiltonian  interaction ::InteractionOffdiagonal   source  #  HartreeFockBogoliubov.Spec.addinteraction!     Method .  addinteraction!  Arguments   hamiltonian ::Hamiltonian  interaction ::InteractionDiagonal   source  #  HartreeFockBogoliubov.Spec.hoppingbycarte     Method .  hoppingbycarte{T}  Arguments   uc ::UnitCell{T}  amplitude ::Number  i ::T  j ::T  ri ::CarteCoord  rj ::CarteCoord  tol ::Real  : Optional. Defaults to  sqrt(eps(Float64))   source  #  HartreeFockBogoliubov.Spec.hoppingbycarte     Method .  hoppingbycarte{T}  Arguments   uc ::UnitCell{T}  amplitude ::Real  i ::T  ri ::CarteCoord  tol ::Real  : Optional. Defaults to  sqrt(eps(Float64))   source  #  HartreeFockBogoliubov.Spec.interactionbycarte     Method .  interactionbycarte{T}  Arguments  * `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `k ::T`\n* `l ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `rk ::CarteCoord`\n* `rl ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`  source  #  HartreeFockBogoliubov.Spec.interactionbycarte     Method .  interactionbycarte{T}  Arguments  * `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`  source", 
            "title": "Spec"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#generator", 
            "text": "#  HartreeFockBogoliubov.Generator.generatefast     Method .  generatefast  source  #  HartreeFockBogoliubov.Generator.generatefast     Method .  generatefast  source  #  HartreeFockBogoliubov.Generator.generatefast     Method .  generatefast  source  #  HartreeFockBogoliubov.Generator.generatehoppingfast     Method .  generatefast  source", 
            "title": "Generator"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#topology", 
            "text": "#  HartreeFockBogoliubov.Topology.squarify     Method .  squarify  Arguments   uc::HFB.HFBHamiltonian{O}   source  #  HartreeFockBogoliubov.Topology.squarify     Method .  squarify  In order to make the Hamiltoinian a periodic function of momentum, bring all the sites to the origin. In addition, make the unitcell into a square.  Arguments   uc::Lattice.UnitCell{O}   source  #  HartreeFockBogoliubov.Topology.squarify     Method .  squarify  Arguments   uc::Spec.FullHamiltonian{O}   source  #  HartreeFockBogoliubov.Topology.timereversalindexgrid     Method .  generate k-space grid (which has (2 n1, 2 n2) points TOTAL in the Brillouin zone)  source  #  HartreeFockBogoliubov.Topology.z2index     Method .  z2index  Compute Z2 index of time-reversal-invariant Hamiltonian.  Arguments   uc::UnitCell{O}  hops::AbstractVector{Hopping}  timereversal::AbstractMatrix  n1 ::Integer  n2 ::Integer  selectpairs::AbstractVector{ :Integer}   Optional Arguments   tol ::Real = sqrt(eps(Float64))   Return  source", 
            "title": "Topology"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#hfb", 
            "text": "#  HartreeFockBogoliubov.HFB.HFBComputer     Type .  HFBConmputer  is a type holding the \u03c1, t and \u0393, \u0394 of a Hartree-Fock-Bogoliubov Hamiltonian.  source  #  HartreeFockBogoliubov.HFB.HFBComputer     Method .  source  #  HartreeFockBogoliubov.HFB.HFBHamiltonian     Type .  source  #  HartreeFockBogoliubov.HFB.HFBHamiltonian     Method .  source  #  HartreeFockBogoliubov.HFB.HFBHamiltonian     Method .  source  #  HartreeFockBogoliubov.HFB.HFBSolver     Type .  source  #  HartreeFockBogoliubov.HFB.HFBSolver     Method .  source  #  HartreeFockBogoliubov.HFB.addinteraction!     Method .  Add offdiagonal interaction  source  #  HartreeFockBogoliubov.HFB.addinteraction!     Method .  Add diagonal interaction  source  #  HartreeFockBogoliubov.HFB.computetargetfields     Method .  Compute \u0393 and \u0394 from \u03c1 and t.  source  #  HartreeFockBogoliubov.HFB.fixhfbsolution     Method .  Recompute \u0393 and \u0394 from \u03c1 and t in a  HFBSolution  source  #  HartreeFockBogoliubov.HFB.freeze     Method .  freeze\n\nCreate a hopping hamiltonian out of HFB Hamiltonian and Solution\n\nOrder:\nelectrons......, HOLE......  source  #  HartreeFockBogoliubov.HFB.getnextsolution     Method .  source  #  HartreeFockBogoliubov.HFB.getnextsolutionpython     Method .  source  #  HartreeFockBogoliubov.HFB.makeDeltamatrix     Method .  Return a generator of \u0394 matrix (which is a function of momentum)  source  #  HartreeFockBogoliubov.HFB.makeGammamatrix     Method .  Return a generator of \u0393 matrix (which is a function of momentum)  source  #  HartreeFockBogoliubov.HFB.makegreencollectors     Method .  makegreencollectors  Returns a function which has the following signature  collector(k, eigenvalues, eigenvectors, \u03c1out, tout)  source  #  HartreeFockBogoliubov.HFB.makehamiltonian     Method .  source  #  HartreeFockBogoliubov.HFB.makehoppingmatrix     Method .  Return a generator of hopping matrix (which is a function of momentum)  source  #  HartreeFockBogoliubov.HFB.makesourcefields     Method .  func : (idx, i, j, r) -  val  source  #  HartreeFockBogoliubov.HFB.makesourcefields     Method .  func : (idx, i, j, r) -  0  source  #  HartreeFockBogoliubov.HFB.newhfbhint     Method .  source  #  HartreeFockBogoliubov.HFB.newhfbsolution     Method .  Check if hint contains \u03c1  source  #  HartreeFockBogoliubov.HFB.newhfbsolution     Method .  Return a zero solution  source  #  HartreeFockBogoliubov.HFB.randomize!     Method .  Randomize a solution  source  #  HartreeFockBogoliubov.HFB.CollectRow     Type .  CollectRow  is holds info on how to compute \u03c1 or t. Its elements are:   Is diagonal? (only for rho)  row orbital  col orbital  displacement r(col) - r(row)   source  #  HartreeFockBogoliubov.HFB.DeployRow     Type .  DeployRow  is holds info on how to compute \u0393 or \u0394. Its elements are:   Is diagonal  row orbital  col orbital  displacement r(col) - r(row)  list of sources, each of which is a tuple of  index of \u03c1 or t from which to compute this \u0393 or \u0394.  amplitude (coefficient to multiply to \u03c1 or t)  boolean indicating whether   (1) conjugation is needed (for \u03c1/\u0393) or   (2) minus sign is needed (for t/\u0394).   source  #  HartreeFockBogoliubov.HFB.HoppingMeanField     Type .  source  #  HartreeFockBogoliubov.HFB.PairingMeanField     Type .  source  #  HartreeFockBogoliubov.HFB.getnextsolutionthreaded     Method .  source  #  HartreeFockBogoliubov.HFB.makeparticleholeregistry     Method .  source  #  HartreeFockBogoliubov.HFB.makeparticleparticleregistry     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source", 
            "title": "HFB"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#linearizedgap", 
            "text": "", 
            "title": "LinearizedGap"
        }
    ]
}